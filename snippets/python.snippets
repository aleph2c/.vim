###########################################################################
#							 TEXTMATE SNIPPETS							  #
###########################################################################
# trying something new
#! header
snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python
$0
endsnippet

snippet ifmain "ifmain" b
if __name__ == '__main__':
	$0
endsnippet

##########
# COMMON #
##########

snippet if "if statement"
if ${1:condition}:
	${0:# code}
endsnippet

snippet else "else block"
else:
	${0: #code}
endsnippet

snippet elif "else-if block"
elif ${1:condition}:
	${0:# code}
endsnippet

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.

global !p
import os
NORMAL	= 0x1
DOXYGEN = 0x2
SPHINX	= 0x3

global_state_name = None

def remove_extension(filename):
	return os.path.splitext(filename)[0] 

def fix_indent(snip):
  snip.unshift(2)
  return snip.mkline(line="")

def get_args(arglist):
	args = [arg.split('=')[0].strip() for arg in arglist.split(',') if arg]
	args = [arg for arg in args if arg and arg != "self"]
	return args

def get_style(snip):
	style = snip.opt("g:ultisnips_python_style", "normal")
	if style == "doxygen":
		return DOXYGEN
	elif style == "sphinx":
		return SPHINX
	else:
		return NORMAL

def make_handler(state_name, signal):
	result = ""
	result = state_name 
	result += "_"
	result += signal.lower()
	return result

def from_options(t, options):
	if t:
		options = [m[len(t):] for m in options if m.startswith(t)]
	if len(options) == 1:
		return options[0]
	else:
		return "(" + "|".join(options) + ")"

def format_arg(arg, style):
	if style == DOXYGEN:
		return "@param %s @todo" % arg
	elif style == SPHINX:
		return ":param %s: @todo" % arg
	elif style == NORMAL:
		return ":%s: @todo" % arg

def format_return(style):
	if style == DOXYGEN:
		return "@return: @todo"
	elif style in (NORMAL, SPHINX):
		return ":returns: @todo"

def write_docstring_args(args, snip):
	if not args:
		snip.rv += ' """'
		return

	snip.rv += '\n' + snip.mkline('', indent='')

	style = get_style(snip)

	for arg in args:
		snip += format_arg(arg, style)


def write_init_body(args, parents, snip):
	parents = [p.strip() for p in parents.split(",")]
	parents = [p for p in parents if p != 'object']

	for p in parents:
		snip += p + ".__init__(self)"

	if parents:
		snip.rv += '\n' + snip.mkline('', indent='')

	for arg in args:
		snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
	args = ['"%s"' % arg for arg in args]
	snip += '__slots__ = (%s,)' % ', '.join(args)

endglobal

########################################
# Class & Special Method Name Snippets #
########################################

snippet class "class with docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += '"""'

write_init_body(args, t[2], snip)
`
		$0
endsnippet

snippet method "method with dynamic docblock"
  def ${1}(self, ${2}):
`!p
# Currently Ultisnips does not support dynamic tabstops, so we cannot add
# tabstops to the datatype for these param tags until that feature is added.
def format_args(arguments):
  index = 1
	# we add the '|' to make the arg lists appear on seperate lines.
	# (I'm starting to wonder about rst... it fills the code with clutter and
	# distracting garbage)
  for arg in arguments:
		if arg == '*args':
			string1  = "       | \`\`%s\`\`: variable length arguement list" % (arg)
		elif arg == '**kwargs':
			string1  = "       | \`\`%s\`\`: arbitrary keyword arguements" % (arg)
		else:
			string1  = "       | \`\`%s\`\` (type1): " % (arg)
    yield (string1)
    index += 1

arguments = t[2].split(',')
arguments = [argument.strip() for argument in arguments if argument]

if len(arguments):
  fargs = format_args(arguments)
  tags = [next(fargs) for index in range(len(arguments))] 
	snip.rv = "    '''short description\n"
	snip.rv += "\n"
	snip.rv += "    longer description\n"
	snip.rv += "\n"
	snip.rv += "    **Note**:\n"
	snip.rv += "       Do this not that recommendation\n"
	snip.rv += "\n"
	snip.rv += "    **Args**:"
	for tag in tags:
		snip += tag
	snip.rv += "\n\n"
	snip.rv += "    **Returns**:\n"
	snip.rv += "       (type): \n"
	snip.rv += "\n"
	snip.rv += "    **Example(s)**:\n"
	snip.rv += "      \n"
  snip.rv += "    .. code-block:: python\n"
  snip.rv += "       \n"
  snip.rv += "       "
	snip.rv += "\n"
	snip += "    '''"
	snip += ''
else:
	snip.rv = ''
`    ${0:${VISUAL}}
endsnippet

snippet handler "write and empty handler"
@staticmethod
def $1(cc, e):
  status = return_status.HANDLED
	return status
$0
endsnippet

snippet module "python module documentation"
"""$1

The $1 module $0

**Example(s)**:
  Here is how you can build a ...

  .. code-block:: python

    code goes here

The ``$1`` module provides a lot of features which can be read about in `the
full spaced-package documentation <https://aleph2c.github.io/spaced/>`_

"""
endsnippet

snippet att "write a docstring for an attribute"
"""($1): $2"""$0
endsnippet

snippet slotclass "class with slots and docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""
`!p
snip >> 1
args = get_args(t[4])
write_slots_args(args, snip)
`

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += '"""'

write_init_body(args, t[2], snip)
`
		$0
endsnippet

snippet doctest "method to put in main for doctest" b
import doctest
doctest.testmod()
endsnippet

snippet contain "methods for emulating a container type" b
def __len__(self):
	${1:pass}

def __getitem__(self, key):
	${2:pass}

def __setitem__(self, key, value):
	${3:pass}

def __delitem__(self, key):
	${4:pass}

def __iter__(self):
	${5:pass}

def __reversed__(self):
	${6:pass}

def __contains__(self, item):
	${7:pass}
endsnippet


snippet context "context manager methods" b
def __enter__(self):
	${1:pass}

def __exit__(self, exc_type, exc_value, traceback):
	${2:pass}
endsnippet


snippet attr "methods for customizing attribute access" b
def __getattr__(self, name):
	${1:pass}

def __setattr__(self, name, value):
	${2:pass}

def __delattr__(self, name):
	${3:pass}
endsnippet


snippet desc "methods implementing descriptors" b
def __get__(self, instance, owner):
	${1:pass}

def __set__(self, instance, value):
	${2:pass}

def __delete__(self, instance):
	${3:pass}
endsnippet


snippet cmp "methods implementing rich comparison"
def __eq__(self, other):
	${1:pass}

def __ne__(self, other):
	${2:pass}

def __lt__(self, other):
	${3:pass}

def __le__(self, other):
	${4:pass}

def __gt__(self, other):
	${5:pass}

def __ge__(self, other):
	${6:pass}

def __cmp__(self, other):
	${7:pass}
endsnippet


snippet repr "methods implementing string representation"
def __repr__(self):
endsnippet

snippet debugger "add a break point in your code" b
import pdb; pdb.set_trace()
endsnippet

snippet pp "pretty print routine" b
import pprint
def pp(item):
	pprint.pprint(item)
endsnippet

snippet "(E|e)vent" "create an Event" r
Event(signal=signals.${1:event_name}))$0
endsnippet

snippet s "create a string" 
'${1:string}'$0
endsnippet

snippet fs "create a formatted string"
"${1:string}".format($0)
endsnippet

snippet flat "create a flat state" b
@spy_on
def ${1:state_function_name}(${2:chart}, e):
  status = return_status.UNHANDLED
  if(e.signal == signals.ENTRY_SIGNAL):
    status = return_status.HANDLED
  elif(e.signal == signals.INIT_SIGNAL):
	  status = return_status.HANDLED
  else:
    chart.temp.fun = ${2:parent_state}
    status = return_status.SUPER
	return status

endsnippet

snippet call "create a callback method" b
@staticmethod
def ${1:state_function_name}(${2:chart}, e):
	status = return_status.HANDLED
	$3
	return status
$0
endsnippet

snippet state "create a state" b
self.${1:state_name} = self.create(state="$1"). \
  catch(signal=signals.${2:signal},
	  handler=self.`!p snip.rv=make_handler(t[1], t[2])`). \
  $3`!p snip.rv=from_options(t[3], ['catch', 'to_method()'])`$0
endsnippet

snippet imports "pick import type" b
$1`!p snip.rv=from_options(t[1], ['active_object_imports', 'factory_imports'])`
endsnippet

snippet factory_imports "miros imports" b 
import time
import logging
from collections import deque
from collections import namedtuple

from miros import Event
from miros import signals
from miros import Factory
from miros import return_status
$0
endsnippet

snippet active_object_imports "miros imports" b 
import time
from collections import namedtuple

from miros import Event
from miros import spy_on
from miros import signals
from miros import ActiveObject
from miros import return_status
$0
endsnippet

snippet ifactory "instrumented factory" b
class InstrumentedFactory(Factory):
  def __init__(self, name, log_file=None, live_trace=None, live_spy=None):
    super().__init__(name)
    self.live_trace = False if live_trace == None else live_trace
    self.live_spy = False if live_spy == None else live_spy
    self.log_file = '`!p snip.rv=remove_extension(fn)`.log' if log_file == None else log_file

    self._output = deque(maxlen=1)
    self._output = {}

    with open(self.log_file, "w") as fp:
		  fp.write("")

    logging.basicConfig(
		  format('%(asctime)s %(levelname)s:%(message)s',
      filename=self.log_file,
      level=logging.DEBUG)

    self.register_live_spy_callback(partial(self.spy_callback))
    self.register_live_trace_callback(partial(self.spy_callback))

  @property
  def output(self):
    return self._output[-1]

  @output.setter
  def output(self, item):
    self._output.append(item)

  def trace_callback(self, trace):
    '''trace without datetimestamp'''
    trace_without_datetime = re.search(r'(\[.+\]) (\[.+\].+)', trace).group(2)
    logging.debug("T: " + trace_without_datetime)

  def spy_callback(self, spy):
    '''spy with machine name pre-pending'''
    logging.debug("S: [{}] {}".format(self.name, spy))

$0
endsnippet

snippet factory "miros factory or ifactory class" b
class ${1:StateChartName}($2`!p snip.rv=from_options(t[2], ['InstrumentedFactory', 'Factory'])`):
  def __init__(self, name, ${3:argument,} live_trace=None, live_spy=None):
    '''comment'''
		`!p 
def is_ifactory():
  previous_line=snip.buffer.cursor[0]-1
  while(re.search('class', snip.buffer[previous_line]) == False):
    previous_line -= 1
	if(re.search('InstrumentedFactory', snip.buffer[previous_line]) or
	   re.search('InstrumentedFactory', snip.buffer[previous_line-1]) or
	   re.search('InstrumentedFactory', snip.buffer[previous_line-2]) or
	   re.search('InstrumentedFactory', snip.buffer[previous_line-3])):
		return  True
	else:
		return False
snip.rv='super().__init__(name, live_trace, live_spy)' if is_ifactory() else \
	'super().__init__(name)'`
    $0
endsnippet

snippet '''comment''' "factory or ifactory comment" 
'''$0`!p
def f_args(arguments):
  index = 1
	# we add the '|' to make the arg lists appear on seperate lines.
	# (I'm starting to wonder about rst... it fills the code with clutter and
	# distracting garbage)
  for arg in arguments:
		if arg == '*args':
			string1  = "       | \`\`%s\`\`: variable length arguement list" % (arg)
		elif arg == '**kwargs':
			string1  = "       | \`\`%s\`\`: arbitrary keyword arguements" % (arg)
		elif arg == 'live_trace=None':
			string1  = "       | \`\`%s\`\`: enable live_trace feature?" % (arg)
		elif arg == 'live_spy=None':
			string1  = "       | \`\`%s\`\`: enable live_spy feature?" % (arg)
		else:
			string1  = "       | \`\`%s\`\` (type1): " % (arg)
    yield (string1)
    index += 1

if not snip.c:
  row, col = vim.current.window.cursor
  previous_line=snip.buffer[int(row)-2]
  m = re.search('__init__(\(.+)\)', previous_line)
  if len(m.groups()) == 1:
    args = m.group(1).split(',')[1:]
		args = [arg.strip() for arg in args if arg]
    tags = f_args(args)
    snip.rv = "short description\n"
    snip.rv += "\n"
    snip.rv += "    longer description\n"
    snip.rv += "\n"
    snip.rv += "    **Note**:\n"
    snip.rv += "       Do this not that recommendation\n"
    snip.rv += "\n"
    snip.rv += "    **Args**:\n"
    for tag in tags:
      snip.rv += tag + "\n"
    snip.rv += "\n\n"
    snip.rv += "    **Returns**:\n"
    snip.rv += "       (type): \n"
    snip.rv += "\n"
    snip.rv += "    **Example(s)**:\n"
    snip.rv += "      \n"
    snip.rv += "    .. code-block:: python\n"
    snip.rv += "       \n"
    snip.rv += "       # example code goes here"
    snip.rv += "\n"
    snip += ''
`'''
endsnippet

#def is_class_line(line):
#  m = re.search('(class)', line)
#  try:
#    m.group(1)
#    result = True
#  else:
#    result = False
#
#previous_line=snip.buffer.cursor[0]-1
#while(is_class_line(snip.buffer[previous_line]) == False):
#  previous_line -= 1
#m = re.search('(InstrumentedFactory)', snip.buffer[previous_line])
#try:
#  m.group(1)
#  snip.rv='super().__init__(name, live_trace, live_spy)'
#except:
#  snip.rv='super().__init__(name)'
#class ${1:StateChartName}($2`!p snip.rv=from_options(t[2], ['Factory', 'InstrumentedFactory')`):
#  def __init__(self, name, live_trace=None, live_spy=None${3:other arguments}):
#    super().__(name, live_trace, live_spy)

#
#def is_class_line(line):
#  m = re.search('(class)', line)
#  try:
#    m.group(1)
#    result = True
#  else:
#    result = False
#previous_line=snip.buffer.cursor[0]-1
#while(is_class_line(snip.buffer[previous_line]) == False):
#  previous_line -= 1
#m = re.search('(InstrumentedFactory)', snip.buffer[previous_line])
#try:
#  m.group(1)
#  snip.rv='super().__init__(name, live_trace, live_spy)'
#except:
#  snip.rv='super().__init__(name)'
#

snippet catch "create a catch" b
catch(signal=signals.${1:signal_name},
  handler=self.`!p 
def is_state_line(state_line):
	m = re.search('state="(.+)"', state_line)
	try:
		m.group(1)
		result = True
	except:
		result = False
	return result
previous_line=snip.buffer.cursor[0]-1
while(is_state_line(snip.buffer[previous_line]) == False):
	previous_line -= 1
m = re.search('state="(.+)"', snip.buffer[previous_line])
state_name = m.group(1)
snip.rv=make_handler(state_name, t[1])`). \
$2`!p snip.rv=from_options(t[2], ['catch', 'to_method'])`$0
endsnippet

#post_expand "snip.buffer[snip.snippet_end[0]+1:snip.snippet_end[0]+1] = ['']"
#post_expand "fix_indent(snip)"
snippet to_method "end state and change indent" 
`!p snip.rv = snip.mkline("to_method()\n\n")
snip.unshift(2)
snip.rv += snip.mkline("  ")
`$1`!p snip.rv=from_options(t[1], ['state', 'nest_start'])`
endsnippet

snippet nest_start "starting nest pattern" 
self.nest(self.${1:top_state}, parent=None). \
     nest
endsnippet

snippet nest "next nest chart" 
nest(self.${1:state}, parent=self.${2:parent_state}). \
nest
endsnippet

snippet oneshot "create a oneshot" 
${1:chart}.post_fifo(
  Event(signal=signals.${2:signal_name}),
	times=1,
	period=${3:period_in_seconds},
	deferred=True)$0
endsnippet

snippet payload "created namedtuple payload" b
${1:NamedPayload} = \
  namedtuple('$1', ['$2', $0 ])
endsnippet

# vim:ft=snippets:
