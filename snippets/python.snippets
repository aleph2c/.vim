###########################################################################
#							 TEXTMATE SNIPPETS							  #
###########################################################################

#! header
snippet #! "Shebang header for python scripts" b
#!/usr/bin/env python
$0
endsnippet

snippet ifmain "ifmain" b
if __name__ == '__main__':
	${1:main()}$0
endsnippet

##########
# COMMON #
##########

snippet if "if statement"
if ${1:condition}:
	${0:# code}
endsnippet

snippet else "else block"
else:
	${0: #code}
endsnippet

snippet elif "else-if block"
elif ${1:condition}:
	${0:# code}
endsnippet

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.

global !p

NORMAL	= 0x1
DOXYGEN = 0x2
SPHINX	= 0x3

def get_args(arglist):
	args = [arg.split('=')[0].strip() for arg in arglist.split(',') if arg]
	args = [arg for arg in args if arg and arg != "self"]
	return args

def get_style(snip):
	style = snip.opt("g:ultisnips_python_style", "normal")
	if style == "doxygen":
		return DOXYGEN
	elif style == "sphinx":
		return SPHINX
	else:
		return NORMAL

def format_arg(arg, style):
	if style == DOXYGEN:
		return "@param %s @todo" % arg
	elif style == SPHINX:
		return ":param %s: @todo" % arg
	elif style == NORMAL:
		return ":%s: @todo" % arg

def format_return(style):
	if style == DOXYGEN:
		return "@return: @todo"
	elif style in (NORMAL, SPHINX):
		return ":returns: @todo"

def write_docstring_args(args, snip):
	if not args:
		snip.rv += ' """'
		return

	snip.rv += '\n' + snip.mkline('', indent='')

	style = get_style(snip)

	for arg in args:
		snip += format_arg(arg, style)


def write_init_body(args, parents, snip):
	parents = [p.strip() for p in parents.split(",")]
	parents = [p for p in parents if p != 'object']

	for p in parents:
		snip += p + ".__init__(self)"

	if parents:
		snip.rv += '\n' + snip.mkline('', indent='')

	for arg in args:
		snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
	args = ['"%s"' % arg for arg in args]
	snip += '__slots__ = (%s,)' % ', '.join(args)

endglobal

########################################
# Class & Special Method Name Snippets #
########################################

snippet class "class with docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += '"""'

write_init_body(args, t[2], snip)
`
		$0
endsnippet

snippet method "method with dynamic docblock"
  def ${1}(self, ${2}):
`!p
# Currently Ultisnips does not support dynamic tabstops, so we cannot add
# tabstops to the datatype for these param tags until that feature is added.
def format_args(arguments):
  index = 1
	# we add the '|' to make the arg lists appear on seperate lines.
	# (I'm starting to wonder about rst... it fills the code with clutter and
	# distracting garbage)
  for arg in arguments:
		if arg == '*args':
			string1  = "       | \`\`%s\`\`: variable length arguement list" % (arg)
		elif arg == '**kwargs':
			string1  = "       | \`\`%s\`\`: arbitrary keyword arguements" % (arg)
		else:
			string1  = "       | \`\`%s\`\` (type1): " % (arg)
    yield (string1)
    index += 1

arguments = t[2].split(',')
arguments = [argument.strip() for argument in arguments if argument]


if len(arguments):
  fargs = format_args(arguments)
  tags = [next(fargs) for index in range(len(arguments))] 
	snip.rv = "    '''short description\n"
	snip.rv += "\n"
	snip.rv += "    longer description\n"
	snip.rv += "\n"
	snip.rv += "    **Note**:\n"
	snip.rv += "       Do this not that recommendation\n"
	snip.rv += "\n"
	snip.rv += "    **Args**:"
	for tag in tags:
		snip += tag
	snip.rv += "\n\n"
	snip.rv += "    **Returns**:\n"
	snip.rv += "       (type): \n"
	snip.rv += "\n"
	snip.rv += "    **Example(s)**:\n"
	snip.rv += "      \n"
  snip.rv += "    .. code-block:: python\n"
  snip.rv += "       \n"
  snip.rv += "       >>> [factorial(n) for n in range(6)]\n"
  snip.rv += "       [1, 1, 2, 6, 24, 120]\n"
	snip.rv += "\n"
	snip += "    '''"
	snip += ''
else:
	snip.rv = ''
`    ${0:${VISUAL}}
endsnippet

snippet module "python module documentation"
"""$1

The $1 module $0

**Example(s)**:
  Here is how you can build a ...

  .. code-block:: python

    code goes here

The ``$1`` module provides a lot of features which can be read about in `the
full spaced-package documentation <https://aleph2c.github.io/spaced/>`_

"""
endsnippet

snippet att "write a docstring for an attribute"
"""($1): $2"""$0
endsnippet

snippet slotclass "class with slots and docstrings" b
class ${1:MyClass}(${2:object}):
	"""${3:Docstring for $1 }"""
`!p
snip >> 1
args = get_args(t[4])
write_slots_args(args, snip)
`

	def __init__(self$4):
		"""${5:@todo: to be defined}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += '"""'

write_init_body(args, t[2], snip)
`
		$0
endsnippet

snippet doctest "method to put in main for doctest" b
import doctest
doctest.testmod()
endsnippet

snippet contain "methods for emulating a container type" b
def __len__(self):
	${1:pass}

def __getitem__(self, key):
	${2:pass}

def __setitem__(self, key, value):
	${3:pass}

def __delitem__(self, key):
	${4:pass}

def __iter__(self):
	${5:pass}

def __reversed__(self):
	${6:pass}

def __contains__(self, item):
	${7:pass}
endsnippet


snippet context "context manager methods" b
def __enter__(self):
	${1:pass}

def __exit__(self, exc_type, exc_value, traceback):
	${2:pass}
endsnippet


snippet attr "methods for customizing attribute access" b
def __getattr__(self, name):
	${1:pass}

def __setattr__(self, name, value):
	${2:pass}

def __delattr__(self, name):
	${3:pass}
endsnippet


snippet desc "methods implementing descriptors" b
def __get__(self, instance, owner):
	${1:pass}

def __set__(self, instance, value):
	${2:pass}

def __delete__(self, instance):
	${3:pass}
endsnippet


snippet cmp "methods implementing rich comparison"
def __eq__(self, other):
	${1:pass}

def __ne__(self, other):
	${2:pass}

def __lt__(self, other):
	${3:pass}

def __le__(self, other):
	${4:pass}

def __gt__(self, other):
	${5:pass}

def __ge__(self, other):
	${6:pass}

def __cmp__(self, other):
	${7:pass}
endsnippet


snippet repr "methods implementing string representation"
def __repr__(self):
endsnippet

snippet debugger "add a break point in your code" b
import pdb; pdb.set_trace()
endsnippet

snippet pp "pretty print routine" b
import pprint
def pp(item):
	pprint.pprint(item)
endsnippet

snippet "(E|e)vent" "create an Event" r
Event(signal=signals.${1:event_name}))$0
endsnippet

snippet s "create a string" 
'${1:string}'$0
endsnippet

snippet fs "create a formatted string"
"${1:string}".format($0)
endsnippet

snippet flat "create a flat state" b
def ${1:state_function_name}(${2:self}, e):
	status return_status.UNHANDLED
endsnippet

snippet call "create a callback method" b
def ${1:state_function_name}(${3:chart}, e):
	status = return_status.HANDLED
	$3
	return status
$0
endsnippet

snippet state "create a state" b
self.${1:state_name} = self.create(state="$1"). \
  catch(signal=signals.${2:signal},
	  handler=self.${3:handler}). \
	catch$0
endsnippet
snippet oneshot "create a oneshot" b
${1:chart}.post_fifo(
  Event(signal=signals.${2:signal_name}),
	times=1,
	period=${3:period_in_seconds},
	deferred=True)$0
endsnippet

snippet catch "create a catch" b
catch(signal=signals.${1:signal_name},
  handler=self.${2:handler}). \
catch$0
endsnippet

snippet payload "created namedtuple payload" b
${1:NamedPayload} = \
  namedtuple('$1', ['$2', $0 ])
endsnippet

# vim:ft=snippets:
