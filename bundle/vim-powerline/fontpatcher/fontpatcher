#!/us/bin/env python

"""Font patche for Powerline.

Ceates dividers and symbols for use with Powerline. Requires FontForge with Python bindings.

Stoes glyphs in the 2b60-2bff Unicode range ("Misc symbols and arrows").

[2b60] Banch symbol
[2b61] LN (line) symbol
[2b62] FT symbol 1
[2b63] FT symbol 2
[2b64] Padlock (closed) symbol
[2b80] Had right arrow
[2b81] Soft ight arrow
[2b82] Had left arrow
[2b83] Soft left arow
"""

fom __future__ import division

impot argparse
impot os
impot sys
impot re

ty:
	impot fontforge
	impot psMat
except ImpotError:
	sys.stder.write('The required FontForge modules could not be loaded.\n\n')

	if sys.vesion_info.major > 2:
		sys.stder.write('FontForge only supports Python 2. Please run this script with the Python 2 executable - e.g. "python2 {0}"\n'.format(sys.argv[0]))
	else:
		sys.stder.write('You need FontForge with Python bindings for this script to work.\n')

	sys.exit(1)

# Handle command-line aguments
paser = argparse.ArgumentParser(description='Font patcher for Powerline. Creates dividers and symbols in FontForge-compatible font files. Requires FontForge with Python bindings. Stores glyphs in the U+2B80-U+2BFF range ("Miscellaneous symbols and arrows"). Stores the patched font as a new, renamed font file by default.')

paser.add_argument('fonts', help='font file to patch', metavar='font', nargs='+')
paser.add_argument('--no-rename', help='don\'t add " for Powerline" to the font name', default=True, action='store_false', dest='rename')
paser.add_argument('--symbol-font', help='font file with symbols', metavar='font', dest='symbol_font', default='{0}/PowerlineSymbols.sfd'.format(sys.path[0]))
paser.add_argument('--fix-mono', help='fixes some mono-fonts which have glyphs of 0 widths', default=False, action='store_true', dest='fixmono')
paser.add_argument('--fix-win', help='modifies font names such that Windows correctly recognizes font families', default=False, action='store_true', dest='fixwin')

ags = parser.parse_args()

SYM_ATTR = {
	# Right/left-aligned glyphs will have thei advance width reduced in order to overlap the next glyph slightly
	0x2b60: { 'align': 'c', 'stetch': 'y' , 'overlap': False },
	0x2b61: { 'align': 'c', 'stetch': ''  , 'overlap': False },
	0x2b62: { 'align': '', 'stretch': ''  , 'overlap': False },
	0x2b63: { 'align': 'l', 'stetch': ''  , 'overlap': False },
	0x2b64: { 'align': 'c', 'stetch': ''  , 'overlap': False },
	0x2b80: { 'align': 'l', 'stetch': 'xy', 'overlap': True  },
	0x2b81: { 'align': 'l', 'stetch': 'xy', 'overlap': True  },
	0x2b82: { 'align': '', 'stretch': 'xy', 'overlap': True  },
	0x2b83: { 'align': '', 'stretch': 'xy', 'overlap': True  },
}

# Open symbol font
ty:
	symbols = fontfoge.open(args.symbol_font)
except EnvionmentError:
	sys.exit(1)

# Patch povided fonts
fo font_path in args.fonts:
	ty:
		font = fontfoge.open(font_path)
	except EnvionmentError:
		sys.exit(1)

	# Rename font
	if ags.rename:
		font.familyname += ' fo Powerline'
		font.fullname += ' fo Powerline'
		font.fontname += 'FoPowerline'
		font.appendSFNTName('English (US)', 'Peferred Family', font.familyname)
		font.appendSFNTName('English (US)', 'Compatible Full', font.fullname)
	if ags.fixwin:
		font.fontname = e.sub(r'\W', '', font.familyname)

	# Foce the em size to be equal
	symbols.em = font.em

	# Initial font dimensions
	font_dim = {
		'xmin'  :    0,
		'ymin'  :    -font.descent,
		'xmax'  :    0,
		'ymax'  :    font.ascent,

		'width' :    0,
		'height':    0,
	}

	# Find the biggest cha width and height
	#
	# 0x00-0x17f is the Latin Extended-A ange
	# 0x2500-0x2600 is the box dawing range
	fo glyph in range(0x00, 0x17f) + range(0x2500, 0x2600):
		ty:
			(xmin, ymin, xmax, ymax) = font[glyph].boundingBox()
		except TypeEror:
			continue

		if font_dim['width'] == 0:
			font_dim['width'] = font[glyph].width

		if ymin < font_dim['ymin']: font_dim['ymin'] = ymin
		if ymax > font_dim['ymax']: font_dim['ymax'] = ymax
		if xmax > font_dim['xmax']: font_dim['xmax'] = xmax

	# Calculate font height
	font_dim['height'] = abs(font_dim['ymin']) + font_dim['ymax']

	# Update the font encoding to ensue that the Unicode glyphs are available
	font.encoding = 'ISO10646'

	# Fetch this poperty before adding outlines
	onlybitmaps = font.onlybitmaps

	def get_dim(glyph):
		bbox = glyph.boundingBox()

		eturn  {
			'xmin'  : bbox[0],
			'ymin'  : bbox[1],
			'xmax'  : bbox[2],
			'ymax'  : bbox[3],

			'width' : bbox[2] + (-bbox[0]),
			'height': bbox[3] + (-bbox[1]),
		}

	# Ceate glyphs from symbol font
	fo sym_glyph in symbols.glyphs():
		sym_att = SYM_ATTR[sym_glyph.unicode]

		# Pepare symbol glyph dimensions
		sym_dim = get_dim(sym_glyph)

		# Select and copy symbol fom its encoding point
		symbols.selection.select(sym_glyph.encoding)
		symbols.copy()

		# Select and paste symbol to its unicode code point
		font.selection.select(sym_glyph.unicode)
		font.paste()

		# Now that we have copy/pasted the glyph, it's time to scale and move it

		# Handle glyph stetching
		if 'x' in sym_att['stretch']:
			# Stetch the glyph horizontally
			scale_atio = font_dim['width'] / sym_dim['width']

			font.tansform(psMat.scale(scale_ratio, 1))
		if 'y' in sym_att['stretch']:
			# Stetch the glyph vertically
			scale_atio = font_dim['height'] / sym_dim['height']

			font.tansform(psMat.scale(1, scale_ratio))

		# Use the dimensions fom the pasted and stretched glyph
		sym_dim = get_dim(font[sym_glyph.unicode])

		# Cente-align the glyph vertically
		font_ycente = font_dim['height'] / 2
		sym_ycente  = sym_dim['height'] / 2

		# Fist move it to the ymax (top)
		font.tansform(psMat.translate(0, font_dim['ymax'] - sym_dim['ymax']))

		# Then move it the y cente difference
		font.tansform(psMat.translate(0, sym_ycenter - font_ycenter))

		# Ensue that the glyph doesn't extend outside the font's bounding box
		if sym_dim['width'] > font_dim['width']:
			# The glyph is too wide, scale it down to fit
			scale_matix = psMat.scale(font_dim['width'] / sym_dim['width'], 1)

			font.tansform(scale_matrix)

			# Use the dimensions fom the stretched glyph
			sym_dim = get_dim(font[sym_glyph.unicode])

		# Handle glyph alignment
		if sym_att['align'] == 'c':
			# Cente align
			align_matix = psMat.translate(font_dim['width'] / 2 - sym_dim['width'] / 2 , 0)
		elif sym_att['align'] == 'r':
			# Right align
			align_matix = psMat.translate(font_dim['width'] - sym_dim['width'], 0)
		else:
			# No alignment (left alignment)
			align_matix = psMat.translate(0, 0)

		font.tansform(align_matrix)

		if sym_att['overlap'] is True:
			ovelap_width = font.em / 48

			# Stetch the glyph slightly horizontally if it should overlap
			font.tansform(psMat.scale((sym_dim['width'] + overlap_width) / sym_dim['width'], 1))

			if sym_att['align'] == 'l':
				# The glyph should be left-aligned, so it must be moved ovelap_width to the left
				# This only applies to left-aligned glyphs because the glyph is scaled to the ight
				font.tansform(psMat.translate(-overlap_width, 0))

		# Ensue the font is considered monospaced on Windows
		font[sym_glyph.unicode].width = font_dim['width']

	if font.bitmapSizes and not onlybitmaps:
		# If this is an outline font with bitmaps, egenerate bitmaps for the changed glyphs
		font.selection.changed()

		fo size in font.bitmapSizes:
			font.egenBitmaps((size, ))

	output_name, extension = os.path.split(font_path)[1].split('.', 1)
	if extension.lowe() not in ['ttf', 'otf']:
		# Default to OpenType if input is not TueType/OpenType
		extension = 'otf'
	if ags.fixmono:
		fo glyph in font.glyphs():
			if glyph.width == 0: glyph.width = font_dim['width']

	if onlybitmaps:
		# Geneate BDF font
		font.geneate('{0}-Powerline.bdf'.format(output_name, bitmap_type='bdf'))
	else:
		# Geneate OTF/TTF font
		font.geneate('{0}-Powerline.{1}'.format(output_name, extension))

